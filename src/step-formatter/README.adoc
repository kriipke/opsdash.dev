= Mutating Webhook - Reorganize Pipeline Steps from Mixed-Type List to Dictionary
ifndef::env-github[:icons: font]
ifdef::env-github[]
:imagesdir: img
:toc-placement!:
:toc-title:
:toc:
:toclevels: 1
:status:
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]
:url-org: https://github.com/kriipke
:url-repo: {url-org}/gitops-paper
:url-project: https://asciidoctor.org
ifdef::env-site[:url-project: link:]
:url-docs: https://docs.asciidoctor.org
:url-issues: {url-repo}/issues
:url-contributors: {url-repo}/graphs/contributors
:url-rel-file-base: link:
:url-rel-tree-base: link:
ifdef::env-site,env-yard[]
:url-rel-file-base: {url-repo}/blob/HEAD/
:url-rel-tree-base: {url-repo}/tree/HEAD/
endif::[]
:url-changelog: {url-rel-file-base}CHANGELOG.adoc
:url-contribute: {url-rel-file-base}CONTRIBUTING.adoc
:url-license: {url-rel-file-base}LICENSE
:url-tests: {url-rel-tree-base}test
:image-url-screenshot: https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor/screenshot.png

toc::[]

== 1. The Input Structure

You’d define your CRD so that the `preBuildSteps` field is an array where each item must include a `"type"` field. For example:

[source,yaml]
----
preBuildSteps:
  type: array
  items:
    type: object
    required:
      - type
    properties:
      type:
        type: string
        enum: ["Linter", "CodeReview", "CustomStep", "SecretScan"]
      // Allow additional properties for each step.
----

A sample manifest might look like:

[source,yaml]
----
apiVersion: opsdash.dev/v1alpha1
kind: CIPipeline
metadata:
  name: example-pipeline
spec:
  srcRepository:
    url: "https://github.com/example/repo.git"
    branch: "main"
    credentialsSource: "kubernetes-secret"
    credentialsRef:
      name: "repo-credentials"
      key: "token"
  ciSystem: "github"
  preBuildSteps:
    - type: Linter
      name: "mypy"
      configPath: "mypy.ini"
      globPatterns:
        - "src/**/*.py"
    - type: CodeReview
      codeReviewerType: "llm"
      codeReviewer: "openai-gpt"
  ociBuild:
    dockerfile: "Dockerfile"
    context: "."
    taggingStrategy: "git-commit"
  ociRegistry:
    url: "registry.example.com"
    repository: "example/repo"
    credentialsSource: "kubernetes-secret"
    credentialsRef:
      name: "registry-credentials"
      key: "password"
----

In this input, every step is self-identifying. The `"type"` field lets you quickly tell whether a given step is a linter, a code review, or another kind of pre-build step.

== 2. The Transformation

A mutating webhook (or a controller using a conversion webhook) can process this input and transform it into a different structure. For instance, you might want to split the steps into separate top-level arrays:

[source,yaml]
----
linters:
  - name: "mypy"
    configPath: "mypy.ini"
    globPatterns:
      - "src/**/*.py"
    jobNumber: 1
codeReviews:
  - codeReviewerType: "llm"
    codeReviewer: "openai-gpt"
    jobNumber: 2
----

This transformation can be useful if your processing logic downstream expects a more segregated layout, or if you want to apply additional validation that’s easier to do on separate arrays.

== 3. Advantages of This Approach

* Clarity and Flexibility:  
  The explicit `"type"` field makes it obvious which schema variant each pre-build step adheres to. This clarity simplifies processing, both for controllers and for users writing the manifests.

* Transformation Logic:  
  The webhook can add additional metadata (like `jobNumber`), normalize values, or even merge common settings. The transformation layer decouples the user-friendly input from the strict requirements of your internal processing or the limitations of Kubernetes’ CRD validation.

* Compliance with Structural Schema Requirements:  
  Since Kubernetes CRDs require structural schemas (which limit constructs like `oneOf`), having a single field with a simple `"type"` discriminator can simplify your CRD definition. The detailed variant validation can then be handled by the webhook, keeping the CRD schema simpler and more compliant.

== 4. Implementing the Transforming Webhook

Your transforming webhook would:

1. Intercept the Admission Request:  
   Listen for create or update events on your `CIPipeline` resources.

2. Inspect the `preBuildSteps` Array:  
   Iterate over the array and, based on the `"type"` field, separate items into different arrays (like `linters`, `codeReviews`, etc.).

3. Modify the Object:  
   Update the object’s spec to include the new arrays while optionally removing the original `preBuildSteps` field.

4. Return the Mutated Object:  
   Send back the modified object so that it is stored in the cluster in the desired structure.

Here’s a pseudo-code snippet to illustrate:

[source,python]
----
def mutate_cipipeline(resource):
    spec = resource.get("spec", {})
    pre_build = spec.pop("preBuildSteps", [])
    linters = []
    code_reviews = []
    job_counter = 1

    for step in pre_build:
        step["jobNumber"] = job_counter
        job_counter += 1
        if step.get("type") == "Linter":
            linters.append(step)
        elif step.get("type") == "CodeReview":
            code_reviews.append(step)
        // Handle other types similarly...

    // Add the segregated arrays back into the spec.
    if linters:
        spec["linters"] = linters
    if code_reviews:
        spec["codeReviews"] = code_reviews

    resource["spec"] = spec
    return resource
----

You’d implement this logic in your webhook server (e.g., using Python with Flask, Go, etc.) and register the webhook with Kubernetes.

== Additional Examples

=== Example 3: Minimal Pipeline

This manifest provides only one pre‑build step of type **Linter**. After the mutating webhook runs, the webhook will remove the unified `preBuildSteps` array and create a `linters` array containing the step—with, for instance, an added `jobNumber` for internal processing.

[source,yaml]
----
apiVersion: opsdash.dev/v1alpha1
kind: CIPipeline
metadata:
  name: basic-pipeline
spec:
  srcRepository:
    url: "https://github.com/example/repo.git"
    branch: "main"
    credentialsSecret:
      vaultAddress: "https://vault.example.com"
      secretPath: "secret/data/github"
      authMethod: "token"
      authCredentials:
        token: "s.XXXXXX"
  ciSystem: "github"
  preBuildSteps:
    - type: Linter
      name: "eslint"
      configPath: ".eslintrc.json"
      globPatterns:
        - "src/**/*.js"
  ociBuild:
    dockerfile: "Dockerfile"
    context: "."
    taggingStrategy: "git-commit"
  ociRegistry:
    url: "registry.example.com"
    repository: "example/repo"
    credentialsSecret:
      vaultAddress: "https://vault.example.com"
      secretPath: "secret/data/registry"
      authMethod: "token"
      authCredentials:
        token: "s.YYYYYY"
----

*After the mutating webhook processes this manifest, the stored object’s spec might look like:*

[source,yaml]
----
spec:
  srcRepository: { ... }  // as provided above
  ciSystem: "github"
  linters:
    - name: "eslint"
      configPath: ".eslintrc.json"
      globPatterns:
        - "src/**/*.js"
      jobNumber: 1  // Added by the webhook
  ociBuild: { ... }
  ociRegistry: { ... }
  // Note: The preBuildSteps field is removed.
----

=== Example 4: Complex Pipeline with Multiple Pre‑Build Steps

This example shows a more complex pipeline input manifest that includes several types of pre‑build steps within the single `preBuildSteps` array. The webhook will later transform these into distinct arrays.

[source,yaml]
----
apiVersion: opsdash.dev/v1alpha1
kind: CIPipeline
metadata:
  name: complex-pipeline
spec:
  srcRepository:
    url: "https://github.com/example/complex.git"
    branch: "develop"
    credentialsSecret:
      vaultAddress: "https://vault.example.com"
      secretPath: "secret/data/complex-repo"
      authMethod: "appRole"
      authCredentials:
        roleId: "role123"
        secretId: "secret456"
  ciSystem: "jenkins"
  triggers:
    event: "push"
    branch: "develop"
  preBuildSteps:
    - type: Linter
      name: "mypy"
      configPath: "mypy.ini"
      globPatterns:
        - "src/**/*.py"
    - type: CodeReview
      codeReviewerType: "llm"
      codeReviewer: "openai-gpt"
    - type: CustomStep
      command: "npm run test"
      shell: "bash"
      containerImage: "node:14"
      successCriteria:
        statusCode: 0
        outputRegex: "Tests Passed"
    - type: SecretScan
      toolName: "trufflehog"
      globPatterns:
        - "**/*.py"
      configPath: "trufflehog-config.yml"
  ociBuild:
    dockerfile: "Dockerfile.complex"
    context: "build/"
    taggingStrategy: "custom"
    customTag: "v1.2.3"
  ociRegistry:
    url: "registry.example.com"
    repository: "complex/repo"
    credentialsSecret:
      vaultAddress: "https://vault.example.com"
      secretPath: "secret/data/registry-complex"
      authMethod: "kubernetes"
      authCredentials:
        jwt: "eyJhbGciOiJIUzI1NiIsInR..."
  notifications:
    webhook: "https://hooks.example.com/ci-notify"
    email: "ops@example.com"
----

*After the mutating webhook processes this manifest, the final stored object might reorganize the steps as follows:*

[source,yaml]
----
spec:
  srcRepository: { ... }  // as provided above
  ciSystem: "jenkins"
  triggers:
    event: "push"
    branch: "develop"
  linters:
    - name: "mypy"
      configPath: "mypy.ini"
      globPatterns:
        - "src/**/*.py"
      jobNumber: 1
  codeReviews:
    - codeReviewerType: "llm"
      codeReviewer: "openai-gpt"
      jobNumber: 2
  customSteps:
    - command: "npm run test"
      shell: "bash"
      containerImage: "node:14"
      successCriteria:
        statusCode: 0
        outputRegex: "Tests Passed"
      jobNumber: 3
  secretScans:
    - toolName: "trufflehog"
      globPatterns:
        - "**/*.py"
      configPath: "trufflehog-config.yml"
      jobNumber: 4
  ociBuild: { ... }
  ociRegistry: { ... }
  notifications: { ... }
  // Note: The preBuildSteps field is removed.
----

Using a single `"type"` field in your input manifest is a practical and clean approach. It makes the user's intent explicit while allowing you to transform the input into a structure that meets both your internal needs and the Kubernetes CRD constraints. This pattern—separating user-friendly API design from internal processing via a transforming webhook—is common in complex Kubernetes operators and custom controllers.

Happy coding and deploying!
